==== CREATE TABLE ====
CREATE TABLE EMP_LAB9
(
	ID NUMERIC,
	SALARY NUMERIC,
	
	PRIMARY KEY(ID)
);

==== INSERT GIVEN DATA ====
INSERT INTO EMP_LAB9
(ID, SALARY)
VALUES
(1, 1200),
(2, 2000),
(3, 1600),
(4, 3450),
(5, 4200);

====== DEFINE FUNCTION ======

CREATE FUNCTION CHECKBAL() RETURNS TRIGGER AS $$
	BEGIN
		IF NEW.SALARY < 1000 THEN
			RAISE EXCEPTION 'SALARY SHOULD BE >= 1000';
		END IF;
		RETURN NEW;
	END
$$
LANGUAGE PLPGSQL;

====== DEFINE TRIGGER ======

CREATE TRIGGER BALCHECK
	BEFORE INSERT OR UPDATE
	ON EMP_LAB9
	FOR EACH ROW
	EXECUTE PROCEDURE CHECKBAL();
	
====== QUERIES ======
1. INSERT INTO EMP_LAB9 VALUES (101, 500);
OP: 
ERROR:  SALARY SHOULD BE >= 1000
CONTEXT:  PL/pgSQL function checkbal() line 4 at RAISE

2. INSERT INTO EMP_LAB9 VALUES (101, 5000);
OP: INSERT 0 1

3. INSERT INTO EMP_LAB9 VALUES (102, 2000);
OP: INSERT 0 1

4. UPDATE EMP_LAB9 SET SALARY=700 WHERE ID=101;
OP:
ERROR:  SALARY SHOULD BE >= 1000
CONTEXT:  PL/pgSQL function checkbal() line 4 at RAISE

5. UPDATE EMP_LAB9 SET SALARY=7000 WHERE ID=101;
OP: UPDATE 1


===== CREATE TABLE =====
CREATE TABLE EMP_AUDIT_LAB9
(
	OPERATION VARCHAR(1) NOT NULL,
	STAMP TIMESTAMP NOT NULL,
	USERID TEXT NOT NULL,
	EMPNAME TEXT NOT NULL,
	SAL NUMERIC
);

===== DEFINE FUNCTION =====
CREATE FUNCTION DO_AUDIT_L9() RETURNS TRIGGER AS $TRG_AUDIT_L9$
	BEGIN
		IF(TG_OP = 'DELETE') THEN
			INSERT INTO EMP_AUDIT_LAB9
			SELECT 'D', NOW(), USER, OLD.*;
			RETURN OLD;
		ELSEIF (TG_OP = 'INSERT') THEN
			INSERT INTO EMP_AUDIT_LAB9
			SELECT 'I', NOW(), USER, NEW.*;
			RETURN NEW;
		ELSEIF (TG_OP = 'UPDATE') THEN
			INSERT INTO EMP_AUDIT_LAB9
			SELECT 'U', NOW(), USER, NEW.*;
			RETURN NEW;
		END IF;
		RETURN NULL;
	END
$TRG_AUDIT_L9$
LANGUAGE PLPGSQL;


===== DEFINE TRIGGER =====

CREATE OR REPLACE TRIGGER TRG_AUDIT_L9
AFTER INSERT OR UPDATE OR DELETE 
ON EMP_LAB9
FOR EACH ROW
EXECUTE PROCEDURE DO_AUDIT_L9();

===== QUERIES =====
1. INSERT INTO EMP_LAB9 VALUES(103, 5000);


==== DROP TRIGGER =====
CASCADE : DELETE ALL THE TABLE
RESTRICT : CAN'T DELETE ANY TABLE

ALTER TABLE EMP_LAB9
ENABLE TRIGGER BALCHECK;

ALTER TABLE EMP_AUDIT_LAB9
ENABLE TRIGGER TRG_AUDIT_L9;

ENABLE (BY DEFAULT) : 



 - - - - - - - - - CURSOR  - - - - - - - - -
BEGIN;
DECLARE MYCURSOR_LAB9 CURSOR FOR
	SELECT * FROM EMP_LAB9;
OP:
DECLARE CURSOR

FETCH NEXT FROM MYCURSOR_LAB9;
FETCH 2 FROM MYCURSOR_LAB9;
FETCH PRIOR FROM MYCURSOR_LAB9;
FETCH FIRST FROM MYCURSOR_LAB9;
FETCH LAST FROM MYCURSOR_LAB9;
FETCH ALL FROM MYCURSOR_LAB9; // SPECIAL QUERY
FETCH FORWARD FROM MYCURSOR_LAB9; // SPECIAL QUERY
FETCH BACKWARD FROM MYCURSOR_LAB9; // SPECIAL QUERY
END;
 
* JOURNAL, RECORD BOOK

* 5 QUERIES : 1 FUNCTION, 2 TRIGGERS, 2 CURSORS IN PROJECT
* REPORT (XEROX),





* PRACTICE CURSOR :-

BEGIN;
	DECLARE CURSOR_NAME CURSOR FOR SELECT * FROM TABLE NAME;
		FETCH PRIOR FROM CURSOR_NAME;
		FETCH NEXT FROM CURSOR_NAME;
		FETCH FIRST FROM CURSOR_NAME;
		FETCH LAST FROM CURSOR_NAME;
		FETCH ALL FROM CURSOR_NAME;
		FETCH FORWARD FROM CURSOR_NAME;
		FETCH BACKWARD FROM CURSOR_NAME;
END;


* PRACTICE FUNCTION :-
=> 1.
CREATE OR REPLACE FUNCTION FUNCTION1() RETURN TRIGGER AS
$$
	BEGIN
		IF(NEW.SALARY < 1000) THEN 
			RAISE EXCEPTION 'MIN BALANCE SHOLD BE < 1000';
		END IF;

		RETURN NEW;
	END
$$
LANGUAGE PLPGSQL

2.
CREATE OR REPLACE FUNCTION FUNCTION2 RETURNS TRIGGER AS 
$TRIGGER2$
	BEGIN
		IF(TG_OP = 'INSERT') THEN
			INSERT INTO TABLE2
			SELECT 'I', NOW(), USER, OLD.'*;
			RETURN NEW;
		ELSE IF(TG_OP = 'DELETE') THEN
			INSERT INTO TABLE2
			SELECT 'D', NOW(), USER, OLD.'*;
			RETURN OLD;
		ELSE IF(TG_OP = 'UPDATE') THEN
			INSERT INTO TABLE2
			SELECT 'U', NOW(), USER, OLD.'*;
			RETURN NEW;
		END IF;

		RETURN NULL;
	END
$TRIGGER2$
LANGUAGE PLPGSQL;



* PRACTICE TRIGGERS :-
CREATE TRIGGER TRIIGER_NAME
AFTER
INSERT OR UPDATE ON TABLE_NAME
[OLD, NEW]
FOR EACH ROW 
EXECUTE PROCEDURE PRO_NAME();

E.G. :-
=> 1.
CREATE OR REPLACE TRIGGER TRIGGER_NAME
	BEFORE
	INSERT OR UPDATE ON TABLE1
	FOR EACH ROW
	EXECUTE PROCEDURE FUNCTION1();

=> 2.
CREATE OR REPLACE TRIGGER TRIGGER2
AFTER
INSERT OR UPDATE OR DELETE ON TABLE2
FOR EACH ROW
EXECUTE PROCEDURE FUNCTION2();


* DROP TRIGGER :-
-->DROP TRIGGER TRIGGER_NAME ON TABLE_NAME;

* ENABLE/ DISABLE TRIGGER :-

-->	ALTER TABLE TABLE_NAME
	ENABLE TRIGGER TRIGGER_NAME;

-->	ALTER TABLE TABLE_NAME
	DISABLE TRIGGER TRIGGER_NAME;


